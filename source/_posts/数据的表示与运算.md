---
title: 数据的表示与运算
date: 2025-06-21 11:57:28
tags:
categories:
    - 408
    - 计算机组成原理
mathjax: true
---

## 不同进制间转换
<img src="https://res.cloudinary.com/dkdhhe5fc/image/upload/v1750481280/09b433103c054cf89fef8288781c16ea_msjbm1.jpg" style="height: 800px;" loading="lazy">

## 原码与补码
补码零的表示唯一，且硬件上减法完全等同于加法。字长为 n 的补码，能够表示的数字范围是：
$$[-2^{n-1}, \quad 2^{n-1} - 1]$$
其中补码1000...0表示$-2^{n-1}$因此最小值能多一个

### 原码->补码
正数相同，负数取绝对值转化为二进制然后各位取反+1.
如short型变量x = -8190，我们需要将其转换为二进制的补码表示。首先，将数值8190转换为二进制形式：8190 = 0001 1111 1111 1110B，然后取其二进制补码（负数取反后加1），补码为1110 0000 0000 0010B，转化为16进制为E002H

### 补码->十进制数:
对于一个 **n** 位的二进制补码数 $B = b_{n-1}b_{n-2}...b_1b_0$，其对应的十进制值 $D$ 为：
$$D = -b_{n-1} \times 2^{n-1} + \sum_{i=0}^{n-2} b_i \times 2^i$$

如 01000001：
$D = -0 \times 2^7 + (1 \times 2^6 + 0 \times 2^5 + 0 \times 2^4 + 0 \times 2^3 + 0 \times 2^2 + 0 \times 2^1 + 1 \times 2^0)=65$

11111110
$D = -1 \times 2^7 + (1 \times 2^6 + 1 \times 2^5 + 1 \times 2^4 + 1 \times 2^3 + 1 \times 2^2 + 1 \times 2^1 + 0 \times 2^0)=-2$

### 求补码的负数
将这个数的所有位按位取反，然后在末位加 1

此过程的原理{% post_link 补码与模 "补码与模" %}。

## 运算方法和运算电路
### 定点数的移位运算
- 算术右移时高位补符号位，其他情况都是补0
- 逻辑左移时若高位的1移出，则发生溢出
- 算术左移时如果高位符号变化，则发生溢出(例如[x]补 = 11110100，[2x]补 = 11110100 << 1 = 11101000，这是正确的，不会溢出)
- 算术右移时如果1被移出，则影响精度

### 定点数的加减运算
补码加法直接加，[A-B]<sub>补</sub>=[A]<sub>补</sub>+[-B]<sub>补</sub>. [求补码负数](#求补码的负数)
- 零标志ZF，指示结果是否为0
- 溢出标志OF，仅对有符号数计算有意义
```
      (C_in=1)
        ↓
      0111 1111   (127)
    + 0000 0001   (1)
    -----------------
(C_out=0) ← 1000 0000   (-128)  <-- 结果错误
```
在计算符号位时，`0 + 0 + (来自第7位的进位1)`，所以**进入符号位的进位 $C\_{in} = 1$**。符号位计算结果是 `1`，没有产生新的进位，所以**从符号位出去的进位 $C\_{out} = 0$**。根据公式 `OF = 1 ⊕ 0 = 1`。**溢出标志OF置1。**
- 符号标志SF，就是结果符号位的值
- 进/借位标志CF，**只用于无符号数运算**，加法时out为1说明溢出，减法时out为0说明有借位（{% post_link 减法时的借位标志CF "原理" %}），因此CF=Sub⊕C<sub>out</sub>。x = 10, y = -20 时，执行 x - y则CF=1，因为CF直接计算二进制数，x为正数符号位为0，y为1，必有借位

### 定点数的乘除运算
教材中所说的乘法器是阵列乘法器， 原理与手算一样，初始时被乘数放入X，乘数放入Y，P和C清零，计数器 Cₙ 置为32，每次循环检查Y的最低位若为1，则ALU计算P+X，结果存入P，进位存入C。将 C, P, Y 作为一个整体逻辑上右移一位。C的值移入P的最高位，P的最低位移入Y的最高位，Y的最低位被丢弃，继续循环。最后的结果为Y中的值（如果P不全0，说明溢出）（实际上PY作为一个整体才是乘积，而且两个32位数相乘不会64位，所以这个数值绝对正确，但要把这个数字保存回32位的数据类型则发生溢出）
![乘法器逻辑结构](https://res.cloudinary.com/dkdhhe5fc/image/upload/v1750497497/faceb3a7897a4d8683493a01631150a2_h3yaou.png)
```
          1101   (被乘数 A)
        x 1011   (乘数 B)
        ----------
          1101   (A * B0) -- 第0个部分积
         1101    (A * B1, 左移1位) -- 第1个部分积
        0000     (A * B2, 左移2位) -- 第2个部分积
       1101      (A * B3, 左移3位) -- 第3个部分积
      ------------
      10001111   (最终结果, 143)
```
除法也与手算一样。除法除以0会报错，补码表示的最小整数除以-1会溢出（因为补码可以表示的最小数绝对值比最大数多1），其他情况都不会溢出


## 浮点数的表示与运算
单精度float=1+8+23  双精度double=1+11+52

将十进制 `9.125` 转换为IEEE 754单精度浮点数
1. 转换为二进制1001.001，可得指数为3，尾数为小数点后部分补0，即00100100000000000000000
2. 可得结果 0 | 10000010 | 00100100000000000000000


C语言中不同类型的数字计算会发生类型提升，如float+double会把float转为double再计算