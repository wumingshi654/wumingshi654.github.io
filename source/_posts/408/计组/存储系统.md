---
title: 存储系统
date: 2025-06-22 08:39:12
categories:
    - 408
    - 计算机组成原理
---
计组和操作系统都放这里
## 主存储器
就是常说的内存，主要考察动态随机存储器(DRAM)，是易失性存储器。ROM是只读存储器，速度较慢，只存储一些开机必须的指令(如BIOS)。CPU会连接多个存储芯片，包括RAM和ROM，CPU会把它们视作逻辑上相连的地址空间，CPU想要访问一个内存地址时，会把此地址发到地址总线上，由地址译码器电路解析地址。

[23] 某计算机的 CPU 有 30 根地址线，按字节编址，CPU 和主存芯片连接时，要求主存芯片占满所有可能存储地址空间，并且 RAM 区和 ROM 区所分配的容量大小比为 3: 1，若 RAM 在连续低地址区，ROM 在连续高地址，则 ROM 的地址范围是 ( )。
    A. 0000 0000H ~ 0FFF FFFFH
    B. 1000 0000H ~ 2FFF FFFFH
    C. 3000 0000H ~ 3FFF FFFFH
    D. 4000 0000H ~ 4FFF FFFFH

3:1则只能用28个，选C

**22.17** 某内存条包含8个8192×8192×8位的DRAM芯片,按字节编址,支持突发(burst) 传送方式,对应存储器总线宽度为64位,每个DRAM芯片内有一个行缓冲区(row buffer)。下列关于该内存条的叙述中,不正确的是()。
A.内存条的容量为512MB
B.采用多模块交叉编址方式
C.芯片的地址引脚为26位
D. 芯片内行缓冲有8192×8位

A. `8192 = 8 × 1024 = 2³ × 2¹⁰ = 2¹³`,所以，单个芯片容量 = `2¹³ × 2¹³ × 8` 位 = `2²⁹` 位, 又因为有8个芯片，所以总容量 = `8 × 2²⁹` 位 = `2³²` 位

总容量 (字节) = `2³²` 位 / `8` 位/字节 = `2³² / 2³` 字节 = `2²⁹` 字节。

`1 MB = 1024 KB = 1024 × 1024` 字节 = `2¹⁰ × 2¹⁰` 字节 = `2²⁰` 字节。

总容量 (MB) = `2²⁹` 字节 / `2²⁰` 字节/MB = `2⁹` MB = **512 MB**。

B. 总线宽度为64位代表CPU/内存控制器一次可以从内存条读取 64 位的数据。`8192(行)×8192(列)×8(位宽)` 的规格可知，每个芯片的数据线是 8 位。为了满足一次 64 位的读取需求，内存控制器必须**同时**从 `64位 / 8位/芯片 = 8个` 芯片中读取数据，每个芯片提供 8 位，共同组成 64 位的数据。将数据分散存储在多个独立的存储体（这里是8个DRAM芯片）中，并对它们进行并行访问，这就是典型的**多模块交叉编址**。

C. 要从 8192 个行中选择一行，需要 `log₂(8192) = log₂(2¹³) = 13` 位地址。列同理，总的内部逻辑地址是26位。但DRAM 采用**地址复用技术**。芯片上只有一组地址引脚，数量由行地址和列地址中较大者决定。工作时，先通过 13 个引脚传入行地址（由RAS信号锁存），然后再传入列地址（由CAS信号锁存）。

D. 当DRAM被给予一个行地址后，它会将该物理行上的所有数据一次性读出，暂存到行缓冲区中。后续的列地址操作都是直接从这个高速缓冲区中选取数据，这被称为“行命中”，速度非常快。因此，一整行的数据量就是 `列数 × 数据位宽` = `8192 × 8` 位。

[21] 某计算机的存储器总线中有24位地址线和32位数据线，按字编址，字长为32位。如果000000H~3FFFFFH 为RAM区，那么需要512Kx8位的RAM芯片数为

RAM区共有 $2^{22}$ 个可寻址的单元，字长为32位代表每个地址对应一个32位的字，RAM区的总容量 = (地址单元数) × (每个单元的位数) = $2^{22} \text{ words} \times 32 \text{ bits/word}$
每个芯片为512Kx8位  $= 512 \times 2^{10} \times 8 = 2^{22}$。所以需要32个

按字编址是指内存中的每一个字 (Word) 才有一个唯一的地址，比较古老，32位=4字节, 64位=8字节。现代计算机如x86，ARM都是按字节编址。


[18] 假定 DRAM芯片中存储阵列的行数为r、列数为c,对于一个2K×1位的DRAM芯片,为保证其地址引脚数最少,并尽量减少刷新开销,则r、c的取值分别是()。
A. 2048、1
B. 64、32
C. 32、64
D. 1、2048

要求行列数接近且行数小，选C

[17] 某计算机主存按字节编址，由 4 个 64M x 8 位的 DRAM 芯片采用交叉编址方式构成，并与宽度 为 32 位的存储器总线相连，主存每次最多读写 32 位数据。若 double 型变量 x 的主存地址为 804001AH，则读取 x 需要的存储周期数是

double类型占8个字节，读 32 位 = 4 字节，又因为读内存是对此读取，起始地址必须是 4 的整数倍，所以要从8040018H 开始读3次

[16] 某存储器容量为64KB,按字节编址,地址 4000H~5FFFH为ROM区,其余为RAM区。若采用8K×4位的SRAM芯片进行设计,则需要该芯片的数量是

ROM区地址范围 = $5FFFH - 4000H + 1H = 1FFFH + 1H = 2000H$，由于系统是**按字节编址**的，所以地址的数量就等于字节数，则

$2000H$ (十六进制) = $2 \times 16^3 = 2 \times 4096 = 8192$ (十进制)，因为 $1KB = 1024$ 字节，所以 $8192$ 字节 / $1024$ 字节/KB = $8KB$

RAM容量 = $64KB - 8KB = 56KB$

SRAM芯片规格是 **8K × 4位**，"8K" 指的是芯片的地址线数量可以寻址 $8 \times 1024 = 8192$ 个存储单元。，"4位" 指的是每个存储单元可以存放4位（bit）数据。

所以单个芯片的总容量 = $8K \times 4 = 8192 \times 4 = 32768 bit = 32768 / 8 Bytes = 32768 / 8 / 1024 KB = 4 KB$

所需芯片数量 = $56KB / 4KB = 14$

## 外部存储器
磁盘，固态硬盘等

## 高速缓存存储器
时间局部性： 如果一个内存位置被访问了，那么它在不久的将来很有可能被再次访问，如for循环中的i

空间局部性：如果一个内存位置被访问了，那么它附近的内存位置也很有可能在不久的将来被访问，如遍历数组，CPU顺序执行指令

根据空间局部性，Cache空间被分为块与主存交换信息，主存通常都是按字节编址而Cache块可以是16B/32B。问题就是如何知道一个内存地址要存入哪个Cache块，以32位主存，Cache 数据区大小为 32KB，主存块大小为 32B，直接映射为例。Cache可以分为 $ 1024=2^{10} $，那么主存地址中要有10位指示对应哪个Cache块，然后一个内存地址指向1B，主存块$32=2^5$B，那么需要知道主存加载到Cache块后的偏移量需要5位，最后剩下的位数就是Tag位：

| 标记 (Tag) | Cache行索引 (Index) | 块内偏移 (Offset) |

#### 块内偏移
最低位是块内偏移，它们在物理上相邻，根据空间局部性存入一个Cache行，且行索引Index，标记位相同Tag。又因为存入一个Cache行的索引必然相同，因此只需要比较标记位就能知道某段内存是否在Cache中，可得：

#### 标记位
Index和Offset相同时会被存入同一个Cache块，需要Tag区分

Cache行总位数 = 数据区位数 + 标记位 (Tag) + 脏位(指示是否修改) + 有效位(Cache是易失存储，指示是否有效)

### Cache和主存的映射方式
- 直接映射，Cache行号 = 主存块号 mod Cache总行数，也就是内存的某一块只能存放在Cache的一个指定位置
- 全相联映射，Cache含有标记和数据，可以存储任一块主存
- 组相联映射，分为Q个大小相等的组，主存块固定存储在某一组内，但组内可以在任意Cache块，Cache组号 = 主存块号 mod Cache总组数

比较器用于比较Tag位，那么直接映射根据Cache行索引就能找到Cache块，只需同时比较一个；全相联映射需要同时全部比较(因为是高速缓存，速度最重要)；组相联映射等于路数

### Cache中主存块的替换算法
- 随机
- 先进先出
- 近期最少使用(LRU)

### Cache的一致性问题
解决Cache中的块修改时，主存对应的块怎么办
- 全写法，写入Cache时同时写入主存，由于写主存相对慢，存在一个写缓冲(Write Buffer)处理。
- 回写法，只在Cache被替换出去时写入主存，Cache中设置一个修改位指示是否修改过

[16] 有如下 C 语言程序段:

```c
for (k = 0; k < 1000; k++)
    a[k] = a[k] + 32;
```

若数组 `a` 及变量 `k` 均为 `int` 型, `int` 型数据占 4B, 数据 Cache 采用直接映射方式, 数据区大小为 1KB、块大小为 16B, 该程序段执行前 Cache 为空, 则该程序段执行过程中访问数组 `a` 的 Cache 缺失率约为( )。
A. 1.25%
B. 2.5%
C. 12.5%
D. 25%

C. 因为每个值要读一次，写一次，每次读入Cache四个int，只有第一个的读操作未命中

[24] 若计算机主存地址为 32 位，按字节编址，Cache 数据区大小为 32KB，主存块大小为 32B，采用 直接映射方式和回写（Write Back）策略，则 Cache 行的位数至少是

数据区大小32 Bytes = 256 bit，即有256位。主存块大小 = 32 B = $2^5$ B，因此块内偏移需要5位。Cache有32KB / 32B = 1024行，需要10位。因此标记位 = 32-10-5 = 17位。因此总行数 = 256（数据位）+ 17（标记位） + 1（有效位）+ 1 （脏位） = 275

全相联映射主存地址只有标记 (Tag)和块内偏移 (Offset)，则此时标记位 = 总地址位数 - 块内偏移位数 = 32 - 5 = 27位，总位数 = 256 + 27 + 1 + 1 = 285位

组相联映射中，主存地址被分为 | 标记 (Tag) | 组索引 (Set Index) | 块内偏移 (Offset) |
假设分为4组，Cache总组数 = Cache总行数 / 路数 = 1024 / 4 = 256组 = $2^8$，组索引为8位，标记位 = 总地址位数 - 组索引位数 - 块内偏移位数 = 32 - 8 - 5 = 19位， 总位数 = 256 + 19 + 1 + 1 = 277位

**22.16** 若计算机主存地址为32位,按字节编址,某Cache的数据区容量为32KB,主存块大小为64B,采用8路组相联映射方式,该Cache中比较器的个数和位数分别

8, 20

## 虚拟存储器
虚拟存储器的大小取决于虚拟地址的位数，通常大于主存，因此需要通过页面置换机制连接主存和辅存，与Cache和主存的关系近似。但从辅存读写数据慢得多，因此提高命中率是关键，要采用全相联映射与回写法。现代操作系统实现虚拟存储器的方式主要是页式

### 页式虚拟存储器
把主存和虚拟地址都划分为相同大小的页(与Cache和主存的块也是近似的，只是页更大)。页表在主存中存储有效位(是否已在主存)，脏位(也叫修改位)，引用位和物理地址。“缺页”异常，就是CPU找数据时发现有效位为0。
虚拟地址高位为虚页号，低位为页内偏移地址
物理地址(主存中的地址)高位为物理页号，低位为页内偏移地址

每个进程都有一个页表基址寄存器，存放该进程的页表首地址，据此找到对应的页表首地址，然后根据虚拟地址高位的虚拟页号找到对应的页表项，若装入位为1，则取出物理页号，和虚拟地址低位的页内地址拼接，形成实际物理地址。若装入位为0，说明缺页，需要操作系统进行缺页处理。

快表(TLB)用SRAM实现与页表的关系类似Cache与内存

#### 位图 bitmap
操作系统用来指示页框是否被占用的序列，一bit就对应一个页框
[23.25] 页大小4KB，物理内存16GB，求位图
有 16GB/4KB = 4 * 2^20个页框 / 8 = 2^9 * 2^10 B = 512KB

**22.15** 某计算机主存地址为24位,采用分页虚拟存储管理方式,虚拟地址空间大小为4GB,页大小为
4KB,按字节编址。某进程的页表部分内容如下表所示:

| 虚页号 | 实页号(页框号) | 存在位 |
|---|---|---|
| 82 | 024H | 0 |
| ... | ... | ... |
| 129 | 180H | 1 |
| 130 | 018H | 1 |

当CPU 访问虚拟地址00082840H时,虚实地址转换的结果是( )。

A. 得到主存地址 024840H
B. 得到主存地址 180840H
C. 得到主存地址 018840H
D. 检测到缺页异常

页大小 $4KB = 4 \times 1024 B = 4096 B = 2^{12} B$，则页内偏移需要12位
虚拟地址空间$4GB = 4 \times 2^{30} B = 2^2 \times 2^{30} B = 2^{32} B$，即有32位
虚页号位数 = 总位数 - 偏移位数 = 32 - 12 = 20位
给出的虚拟地址，前20位为虚页号，即00082H = 8 × 16¹ + 2 × 16⁰ = 128 + 2 = 130 (十六进制转十进制)，即虚页号为130
物理地址 = 实页号 拼接 页内偏移 = 018H 拼接 840H = 018840H

另外物理地址同样是页大小为4KB，所以物理页号=24-12=12位，由此可知虚页号可以远大于物理页号的

## 存储系统综合
设某系统满足以下条件：
* 有一个 TLB 与一个 data Cache
* 存储器以字节为编址单位
* 虚拟地址 14 位
* 物理地址 12 位
* 页大小为 64B
* TLB 为四路组相联，共有 16 个条目
* data Cache 是物理寻址、直接映射的，行大小为 4B，共有 16 组

写出访问地址为 0x03d4, 0x00f1 和 0x0229 的过程。

因为本系统以字节编址，页大小为 64B，则页内偏移地址为 $\log_2(64B/1B) = 6$ 位，所以虚拟页号为 $14-6=8$ 位，物理页号为 $12-6=6$ 位。因为 TLB 为四路组相联，共有 16 个条目，则 TLB 共有 $16/4=4$ 组，因此虚拟页号中低 $\log_24 = 2$ 位就为组索引，高 $6$ 位就为 TLB 标记。又因为Cache行大小为4B，因此物理地址低2位为块内偏移，4位组索引，剩下高6位作为标记。

虚拟地址和物理地址的末几位是相同的Cache Index和Offset，因为现代CPU都是并行处理，获取一个虚拟地址时MMU进行地址翻译，同时根据Cache Index和Offset到Cache中获取对应的Tag，与物理地址的Tag对比。
<img src="https://pub-35b33650d5944267a2f7969ac8f72430.r2.dev/8860235223334cd4bb23e669accbbed0.png" style="height:400px; width: 500px"/>

[23.20] 某存储总线宽度为 64 位，总线时钟频率为 1GHz，在总线上传输一个数据或地址需要一个时钟 周期，不支持突发传送方式。若通过该总线连接 CPU 和主存，主存每次准备一个 64 位数据需 要 6ns，主存块大小为 32B，则读取一个主存块时间是 ( )。
A. 8ns
B. 11ns
C. 26ns
D. 32ns

CPU通过存储总线获取数据是发地址，主存准备数据，然后返回，过程8ns，一个主存块32B，需要4次，所以32ns

[23.28] 对于采用虚拟内存管理方式的系统，下列关于进程虚拟地址空间的叙述中，错误的是( )。
A. 每个进程都有自己独立的虚拟地址空间
B. C 语言中 malloc() 函数返回的是虚拟地址
C. 进程对数据段和代码段可以有不同的访问权限
D. 虚拟地址的大小由内存和硬盘的大小决定

D