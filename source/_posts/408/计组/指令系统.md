---
title: 指令系统
date: 2025-06-22 16:48:45
categories:
    - 408
    - 计算机组成原理
---

## 指令寻址和数据寻址
指令寻址都是根据PC获取，顺序寻址时下一个地址就是PC+1(1条指令的长度)，跳跃寻址由本条指令给出PC的计算方式

### 数据寻址
指令包括操作码，寻址特征和形式地址A
- 隐含寻址，没给出操作数的地址，如累加器ACC，操作数由其内部提供
- 立即寻址，指令字中的地址字段指出的不是操作数的地址，而是操作数本身，也称立即数，采用补码表示
- 直接寻址，形式地址A 就是操作数的直实地址EA
- 间接寻址，指令的地址字段给出的不是操作数的真正地址，而是操作数有效地址所在主存单元的地址，也就是操作数地址的地址
- 寄存器寻址，与直接寻址的原理一样， 只是把访问主存改为访问寄存器(寄存器在CPU内部，访问速度最快)， 指令的地址字段给出的是操作数所在寄存器的编号
- 寄存器间接寻址，指令字中的地址所指向的寄存器给出的不是一个操作数， 而是操作数所在主存单元的地址
- 相对寻址，相对寻址是把PC的内容加上指令格式中的形式地址A而形成操作数的有效地址， 即EA =(PC) +A,其中A是相对于当前PC值的偏移量， 可正可负，补码表示。这么做的优点是相对地址是程序内部的相对地址，如程序存储到1000，A=10，那么数据就存储到1010，这样程序就可以任意浮动，不会因为改变到其他地址就找不到数据了
- 基址寻址，基址寻址是指将基址寄存器(BR) 的内容加上指令字中的形式地址A而形成操作数的有效地址，即EA=(BR)+A。其中基址寄存器既可采用专用寄存器，又可指定某个通用寄存器作为基址寄存器，优点是寄存器可以拓展A的位数，进而扩大寻址范围， 在动态重定位中，程序被加载到内存的哪个位置是不确定的。 基址寻址允许程序在加载时，只需设置基址寄存器为程序的起始地址，程序内部的所有内存访问指令 (使用基址寻址的) 就能自动适应新的加载位置，实现代码的浮动。 现代操作系统中，进程通常拥有独立的数据段。  基址寄存器可以指向进程的数据段起始地址，方便程序访问其数据段内的变量和数据结构。 例如，C 语言中的全局变量和静态变量通常就存放在数据段中，可以使用基址寻址来访问。
- 变址寻址，变址寄存器的值加上指令中给出的偏移量，它与上一个的区别是变址寻址的核心目的是**方便对数组、字符串等连续存储的数据结构进行访问**。**变址寄存器通常用于存放索引值或下标值。** 指令中的偏移量则表示数组或字符串的首地址（基地址），或者数组元素的固定偏移量。而变址寄存器在循环中频繁改变。基址寻址中基址寄存器的值指向程序首地址后不会轻易改变

## 程序的机器级代码表示
![](https://res.cloudinary.com/dkdhhe5fc/image/upload/v1750585543/36lj13_c504tu.png)

- \<reg\>: regsiter 寄存器，reg32表示32位寄存器
- \<mem\>: memory 内存
- \<con\>: constant 常数，\<con8\>表示8位常数
指令：
- mov，可以复制第二个操作数到第一个，允许reg<-reg，reg<-mem，mem<-reg，reg<-con，mem<-con，不允许mem<-mem。指令mov byte ptr [var], 5 表示mov是移动指令；byte是大小指示符，表示要操作的数据大小；ptr是指针指示符，表示**紧跟在 `ptr` 后面的操作数是一个内存地址 (指针)**，而不是立即数或寄存器名。[var]是内存寻址，5是要复制的操作数。所以整体意思就是把5复制到var指示的内存地址的一字节中

## 多处理器 并行处理

| 特性 | SISD (单指令单数据) | SIMD (单指令多数据) | MIMD (多指令多数据) |
| :--- | :--- | :--- | :--- |
| **指令流** | 1 | 1 | N (多个) |
| **数据流** | 1 | N (多个) | N (多个) |
| **并行类型** | 无 (或指令级并行) | **数据并行** | **任务并行** |
| **执行方式** | 串行 | 同步并行 | **异步并行** |
| **架构复杂度**| 简单 | 中等 | 复杂 |
| **应用场景** | 传统串行任务 | 图形、科学计算、AI | 通用并行计算、服务器 |
| **典型代表** | 老式单核CPU | GPU, 向量处理器 | **现代多核CPU**, 服务器集群 |

如GPU的核心就是大规模的SIMD架构，它拥有数千个核心，可以同时对图像中的成千上万个像素点执行相同的变换操作。

### 硬件多线程
核心思想是让单个物理核心能够维护多个硬件线程的完整状态（如程序计数器、寄存器组），并在纳秒级别上进行切换。当一个硬件线程因为某些原因（如缓存未命中、等待内存）发生停顿时，核心可以立刻切换到另一个硬件线程去执行，从而提高单个物理核心的利用率，Intel的商业名称叫超线程。在单核处理器上也能使用

### 共享内存多处理器
1.  **UMA (Uniform Memory Access) - 均匀存储访问模型**
    * **核心特征**：所有处理器访问任何内存位置的**时间都相同**。物理内存被所有处理器集中共享。
    * **典型实现**：**对称多处理器 (Symmetric Multiprocessing, SMP)**。在SMP中，所有CPU地位平等，共享所有资源，并运行同一个操作系统内核。这是目前PC和服务器中最常见的模型。
    * **优点**：编程模型简单，负载均衡易于实现。
    * **缺点**：所有处理器共享同一总线和内存，当处理器数量增多时，总线和内存会成为性能瓶颈，**可伸缩性（Scalability）较差**。

2.  **NUMA (Non-Uniform Memory Access) - 非均匀存储访问模型**
    * **核心特征**：处理器访问不同内存区域的**时间不同**。内存被物理上划分为多个模块，每个模块与一组处理器“本地连接”。
    * **工作机制**：访问“本地内存”速度快，访问连接到其他处理器的“远程内存”速度慢。
    * **优点**：通过减少对单一共享总线的争用，**大大提高了可伸缩性**，能够支持更多数量的处理器。
    * **缺点**：编程模型更复杂，需要操作系统和程序员有意识地将进程及其数据放置在本地内存中以获得最佳性能。


## [23.44] 
一个C 程序段在计算机 M 上的部分机器级代码如下，每个机器级代码行中依次包含 指令序号、虚拟地址、机器指令和汇编指令。

```
for (i=0; i<24; i++)
1  00401072 C7 45 F8 00 00 00 00       mov[ebp - 8], 0
2  00401079 EB 09                     jmp 00401084h
3  0040107B 8B 55 F8                     mov eax, [ebp - 8]

7  00401088 7D 32                     jge 004010bch

for (j=0; j<64; j++)
8  0040108A C7 45 FC 00 00 00 00       mov[ebp - 4], 0

    a[i][j] = 10;

19 004010AE C7 84 82 00 20 42 00 0A 00 00 00   mov[ecx + edx * 4 + 00422000h], 0Ah
20 ......                              ......
```

请回答下列问题。
(1) 第 20 条指令的虚拟地址是多少？
(2) 已知第 2 条 jmp 和第 7 条 jge 都是跳转指令，其操作码分别是 EBH 和 7DH，跳转目标地址 分别为 0040 1084H 和 0040 10BCH，这两条指令分别采用什么寻址方式？请给出第 2 条指令 jmp 的跳转目标地址计算过程。
(3) 已知第 19 条 mov 指令的功能是 “a[i][j] = 10”，其中 ecx 和 edx 为寄存器名，0042 2000H 是 数组 a 的首地址，指令中源操作数采用什么寻址方式？已知 edx 中存放的是变量 j, ecx 中存 放的是什么？根据该指令的机器码判断计算机 M 采用的是大端还是小端方式？
(4) 第 1 次执行第 19 条指令时，取指令过程中是否会发生缺页异常？为什么？
好的，我们来逐步分析和解答这道关于C程序和其对应机器级代码的题目。

### (1) 第 20 条指令的虚拟地址是多少？

**求解过程：**

要确定第 20 条指令的地址，我们需要知道第 19 条指令的起始地址和它的长度。

1.  **第 19 条指令的起始地址**： `004010AEH`。
2.  **第 19 条指令的长度**
    * `C7 84 82 00 20 42 00` (7个字节) 是指令操作码和寻址部分。
    * `0A 00 00 00` (4个字节) 是要存入的立即数 `0AH`。
    * 总长度为 7 + 4 = 11 个字节。
3.  **计算第 20 条指令的地址**：第 20 条指令的地址 = 第 19 条指令的地址 + 第 19 条指令的长度=`004010AEH + 11` (十进制) = `004010AEH + BH` (十六进制) = `004010B9H`。

---

### (2) 指令寻址方式及跳转地址计算

**求解过程：**

1.  **寻址方式分析**:
    * **第 2 条指令**: `jmp 00401084h`，其机器码是 `EB 09`。其中 `EB` 是 `jmp` 的操作码，`09` 是一个位移量(offset)。跳转的目标地址是通过当前指令指针 `EIP` (或 `PC`) 加上这个位移量得到的。这种寻址方式称为 **相对寻址 (Relative Addressing)**。
    * **第 7 条指令**: `jge 004010bch`，其机器码是 `7D 32`。其中 `7D` 是 `jge` 的操作码，`32` 也是一个位移量。这也属于 **相对寻址 (Relative Addressing)**。

2.  **第 2 条指令跳转目标地址计算**:
    * 相对寻址的目标地址计算公式为：**目标地址 = 当前指令的下一条指令的地址 + 位移量**。
    * 当前指令 (第 2 条) 的地址是 `00401079H`。
    * 当前指令的长度是 2 字节 (`EB` 和 `09`)。
    * 下一条指令 (第 3 条) 的地址是 `00401079H + 2 = 0040107BH`。
    * 位移量是 `09H`。
    * 目标地址 = `0040107BH + 09H = 00401084H`。
    * 这个计算结果与题目中给出的跳转目标地址 `00401084H` 相符。

**答案：**
* 这两条指令都采用 **相对寻址** 方式。
* 第 2 条指令 `jmp` 的跳转目标地址计算过程为：`00401079H` (当前指令地址) + `2` (当前指令长度) + `09H` (位移量) = **`00401084H`**。

---

### (3) 第 19 条指令分析

**求解过程：**

指令 19: `mov [ecx + edx * 4 + 00422000h], 0Ah`
机器码: `C7 84 82 00 20 42 00 0A 00 00 00`

1.  **源操作数寻址方式**:
    * 指令的功能是将一个值存入内存地址。`[ecx + edx*4 + 00422000h]` 是目标操作数（目的地址），而 `0Ah` (即十进制的 10) 是源操作数。
    * 这个值 `0Ah` 被直接编码在指令的机器码中 (`... 0A 00 00 00`)。操作数直接在指令中给出的寻址方式称为 **立即寻址 (Immediate Addressing)**。

2.  **`ecx` 寄存器的内容**:
    * C 代码中 `a[i][j]` 的地址计算公式为：`a 的首地址 + i * 列数 * sizeof(元素类型) + j * sizeof(元素类型)`。
    * 从 `for (j=0; j<64; j++)` 可知，数组 `a` 的列数为 64。
    * `a[i][j]` 的地址 = `00422000H + i * 64 * 4 + j * 4` (假设 `a` 是 `int` 类型，`sizeof(int)` 为 4)。
    * 地址 = `00422000H + i * 256 + j * 4`。
    * 对比汇编指令中的地址计算 `[ecx + edx * 4 + 00422000h]`，并已知 `edx` 中存放的是变量 `j`。
    * 我们可以建立对应关系：
        * `edx * 4` 对应 `j * 4`
        * `ecx` 对应 `i * 256` (即 `i * 64 * 4`)
    * 因此，`ecx` 中存放的是 **变量 i 的值乘以每行的字节数（256）**，即第 `i` 行相对于数组首地址的偏移量。

3.  **大端/小端判断**:
    * 大小端方式指的是多字节数据在内存中的存储顺序。
        * **大端 (Big-Endian)**: 高位字节存放在低地址，低位字节存放在高地址。
        * **小端 (Little-Endian)**: 低位字节存放在低地址，高位字节存放在高地址。
    * 我们看立即数 `10` (十六进制为 `0AH`) 在机器码中的表示。它是一个 4 字节的整数，完整表示为 `0000000AH`。
    * 在机器码中，它被存储为 `0A 00 00 00`。
    * 最低有效字节 (Least Significant Byte, LSB) `0A` 被存放在了起始位置（低地址），而最高有效字节 (Most Significant Byte, MSB) `00` 被存放在了末尾位置（高地址）。
    * 这种“低对低，高对高”的存储方式是 **小端方式**。

**答案：**
* 源操作数采用 **立即寻址** 方式。
* `ecx` 中存放的是 **变量 i 乘以 256（`i * 256`）** 的值。
* 计算机 M 采用的是 **小端 (Little-Endian)** 方式。

---

### (4) 是否会发生缺页异常？

**求解过程：**

1.  **问题分析**: 题目问的是在 **第 1 次执行** 第 19 条指令时，在 **取指令** 过程中是否会发生缺页异常。
2.  **指令位置**:
    * 第 19 条指令的虚拟地址是 `004010AEH`。
    * 程序执行是顺序的（在没有跳转的情况下）。在执行第 19 条指令之前，CPU 必须已经成功获取并执行了它前面的指令，例如第 8 条指令 (地址 `0040108AH`) 等。
3.  **页面与局部性原理**:
    * 现代计算机的页大小通常是 4KB (`1000H`) 或更大。
    * 我们看程序中指令的地址：`00401072H`, `00401079H`, `0040108AH`, `004010AEH`... 这些地址都非常接近，它们都落在同一个内存页中。例如，对于 4KB 的页，这些地址都属于从 `00401000H` 到 `00401FFFH` 的这个页面。
    * 根据程序的 **空间局部性 (Spatial Locality)** 和 **时间局部性 (Temporal Locality)** 原理，当 CPU 执行到这段代码时，包含这系列指令的整个内存页很可能已经被加载到物理内存中了。如果该页没有在内存中，那么在取第 1 条或第 2 条指令时就已经发生了缺页异常，操作系统会把该页调入内存。
4.  **结论**:
    * 因为在执行第 19 条指令之前，程序必然已经执行了位于同一内存页中的前面的指令（如第 8 条）。这意味着在轮到第 19 条指令被CPU提取时，它所在的内存页必定已经存在于物理内存中。
    * 因此，在为执行而**取**第 19 条指令时，不会发生缺页异常。
    * (注意：这不意味着执行该指令的**数据访问**部分 `mov [ecx + ...]` 不会缺页。访问数组 `a` 所在的地址 `00422000H` 可能会引发缺页，但这属于数据访问缺页，而不是题目所问的取指令缺页。)

**答案：**
**不会** 发生缺页异常。
**原因**：因为第 19 条指令 (`地址 004010AEH`) 与其之前的指令（如第 8 条，地址 `0040108AH`）位于同一个内存页中。根据程序的顺序执行特性和局部性原理，当 CPU 执行到第 19 条指令时，它所在的内存页必定已经被加载到物理内存中。如果该页不在内存中，缺页异常在取前面的指令时就已经发生了。