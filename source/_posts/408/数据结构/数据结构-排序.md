---
title: 数据结构-排序
date: 2025-07-06 13:15:36
categories:
    - 408
    - 数据结构
---

## 算法复杂度分析
算法分析中的**空间复杂度**，特指算法运行所需的**额外辅助空间**，不包括输入数据本身占用的空间。比如插入排序只需要存储一个元素，所以为O(1)。


## 二路归并排序
基于分治法（Divide and Conquer），将数组递归拆分为只含一个元素的数组，两两递归合并，比较头指针
**22.10** **二路归并**的作用是两个有序表合一，不是问拆分过程，属于文字游戏了

## 外部排序
外部排序用于处理大量文件无法加载如内存的情况

### 置换-选择排序
在内存中有一个工作区
1.  **初始化**: 从输入文件中读取前 $m$ 个记录，在工作区中建立一个最小堆(即现在工作区对这m个元素排序)
2.  **循环处理**:
    a. 从最小堆中取出堆顶元素（即当前工作区中关键字最小的记录），将其写入当前的输出归并段。记下这个记录的关键字为 $LastKey$。
    b. 从输入文件中读取下一个记录。设其关键字为 $NextKey$。
    c. **比较**:
        * 如果 $NextKey \ge LastKey$，说明新记录可以归入当前正在生成的归并段。将其加入最小堆。
        * 如果 $NextKey < LastKey$，说明新记录无法归入当前归并段（否则会破坏有序性）。此时，将该记录“冻结”，暂时存放在堆中，但在构建当前归并段的最小堆时，视其关键字为无穷大，不参与选择。这个记录将属于下一个归并段。
    d. 重复 a, b, c，直到堆中所有未被冻结的元素都已输出。
3.  **新归并段**: 当一个归并段生成结束（即堆中所有元素都被冻结）时，将所有冻结的元素“解冻”，它们将构成下一个新归并段的初始堆(因为第二步c是拿走一个才可能冻结一个，所以冻结的元素个数一定小于或等于初始堆)。重复步骤 2，直到所有输入记录都被处理完毕。
4.  **收尾**: 当输入文件读完后，将堆中剩余的所有元素（无论是否冻结）依次取出，写入最后一个归并段。


[23.42] 对含有 $n(n>0)$ 个记录的文件进行外部排序，采用置换-选择排序生成初始归并段时需要使用一个工作区，工作区中能保存 $m$ 个记录，请回答下列问题：
(1) 若文件中有 19 个记录，其关键字依次是 51, 94, 37, 92, 14, 63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100。当 $m=4$ 时，可生成几个初始归并段？每个归并段各是什么？
(2) 对任意 $m(n \gg m > 0)$，生成的第一个初始归并段的长度最大值和最小值分别是多少？

#### (1) 具体案例求解

给定文件记录关键字为：`51, 94, 37, 92, 14, 63, 15, 99, 48, 56, 23, 60, 31, 17, 43, 8, 90, 166, 100`。
工作区大小 $m=4$。

我们将一步步模拟整个过程。工作区 `W` 实现为最小堆，我们用 `[ ]` 表示被冻结的元素。

##### **生成第一个归并段 (R1)**

1.  **初始化**: 读入前 4 个记录 `51, 94, 37, 92`。建立最小堆 `W = {37, 51, 92, 94}`。
2.  **输出 37**: 将 `37` 写入 R1。`LastKey = 37`。
    * 读入下一个记录 `14`。因为 `14 < 37`，所以 `14` 不能加入当前归并段，将其冻结。
    * `W = {51, 92, 94, [14]}`。
3.  **输出 51**: 从堆中（忽略 `[14]`）取出最小元素 `51`，写入 R1。`LastKey = 51`。
    * 读入下一个记录 `63`。因为 `63 > 51`，可以加入当前归并段。
    * `W = {63, 92, 94, [14]}`。
4.  **输出 63**: 从堆中取出最小元素 `63`，写入 R1。`LastKey = 63`。
    * 读入下一个记录 `15`。因为 `15 < 63`，将其冻结。
    * `W = {92, 94, [14], [15]}`。
5.  **输出 92**: 从堆中取出最小元素 `92`，写入 R1。`LastKey = 92`。
    * 读入下一个记录 `99`。因为 `99 > 92`，可以加入。
    * `W = {94, 99, [14], [15]}`。
6.  **输出 94**: 从堆中取出最小元素 `94`，写入 R1。`LastKey = 94`。
    * 读入下一个记录 `48`。因为 `48 < 94`，将其冻结。
    * `W = {99, [14], [15], [48]}`。
7.  **输出 99**: 从堆中取出最小元素 `99`，写入 R1。`LastKey = 99`。
    * 读入下一个记录 `56`。因为 `56 < 99`，将其冻结。
    * `W = {[14], [15], [48], [56]}`。

此时，堆中所有 4 个元素均被冻结。第一个归并段生成结束。
**第一个归并段 R1 = {37, 51, 63, 92, 94, 99}**

---

##### **生成第二个归并段 (R2)**

1.  **初始化**: 将工作区 `W` 中所有冻结的元素解冻，并重新建立最小堆。
    * `W = {14, 15, 48, 56}`。
2.  **输出 14**: `LastKey = 14`。
    * 读入 `23`。因为 `23 > 14`，加入堆。
    * `W = {15, 23, 48, 56}`。
3.  **输出 15**: `LastKey = 15`。
    * 读入 `60`。因为 `60 > 15`，加入堆。
    * `W = {23, 48, 56, 60}`。
4.  **输出 23**: `LastKey = 23`。
    * 读入 `31`。因为 `31 > 23`，加入堆。
    * `W = {31, 48, 56, 60}`。
5.  **输出 31**: `LastKey = 31`。
    * 读入 `17`。因为 `17 < 31`，冻结。
    * `W = {48, 56, 60, [17]}`。
6.  **输出 48**: `LastKey = 48`。
    * 读入 `43`。因为 `43 < 48`，冻结。
    * `W = {56, 60, [17], [43]}`。
7.  **输出 56**: `LastKey = 56`。
    * 读入 `8`。因为 `8 < 56`，冻结。
    * `W = {60, [17], [43], [8]}`。
8.  **输出 60**: `LastKey = 60`。
    * 读入 `90`。因为 `90 > 60`，加入堆。
    * `W = {90, [17], [43], [8]}`。
9.  **输出 90**: `LastKey = 90`。
    * 读入 `166`。因为 `166 > 90`，加入堆。
    * `W = {166, [17], [43], [8]}`。
10. **输出 166**: `LastKey = 166`。
    * 读入 `100`。因为 `100 < 166`，冻结。
    * `W = {[100], [17], [43], [8]}`。

此时，堆中所有 4 个元素再次被冻结。第二个归并段生成结束。
**第二个归并段 R2 = {14, 15, 23, 31, 48, 56, 60, 90, 166}**

---

##### **生成第三个归并段 (R3)**

1.  **初始化**: 将 `W` 中所有元素解冻，建立最小堆。
    * `W = {8, 17, 43, 100}`。
2.  此时，输入文件已经全部读完。因此，只需将堆中所有元素依次取出即可。
3.  **依次输出**: `8, 17, 43, 100`。

第三个归并段生成结束。
**第三个归并段 R3 = {8, 17, 43, 100}**

全部记录处理完毕。

#### **最终答案 (1)**

* **可生成 3 个初始归并段。**
* **R1**: `{37, 51, 63, 92, 94, 99}`
* **R2**: `{14, 15, 23, 31, 48, 56, 60, 90, 166}`
* **R3**: `{8, 17, 43, 100}`

---

#### (2) 第一个初始归并段的长度极值

对于任意 $m(n \gg m > 0)$，我们分析生成的第一个初始归并段的长度。其长度取决于输入记录的初始排列顺序。

##### **最大长度**

要使第一个归并段的长度最长，我们需要尽可能地避免出现“冻结”记录的情况。这种情况在何时发生？当读入的新记录关键字 $NextKey$ 大于或等于 `LastKey` 时，归并段就可以继续增长。

考虑一种最理想的情况：**整个文件中的记录已经按关键字升序排列**。

1.  初始时，读入前 $m$ 个记录（它们是整个文件中最小的 $m$ 个）到工作区并建立最小堆。
2.  输出堆顶元素（即全局最小元素）。
3.  读入第 $m+1$ 个记录。由于文件是升序的，这个记录的关键字必然大于等于刚输出的记录的关键字。因此，它被顺利地加入堆中。
4.  这个过程会一直持续下去。每次从堆中取出的都是当前堆中的最小值，而从文件中读入的新值总是比它大，所以永远不会有记录被“冻结”。
5.  直到文件末尾，所有 $n$ 个记录都被处理，它们构成一个单一的、长度为 $n$ 的归并段。

因此，**生成的第一个初始归并段的长度最大值为 $n$**。

##### **最小长度**

全部冻结，初始归并段中只含有从工作区拿出来的，即m

##### **最终答案 (2)**

* **最大值**: $n$ (当输入文件整体有序时)
* **最小值**: $m$ (当输入文件整体逆序时)