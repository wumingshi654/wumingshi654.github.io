---
title: 数据结构-树
date: 2025-07-06 10:55:53
categories:
    - 408
    - 数据结构
---

树的前中后遍历指的都是根节点，然后左一定在右前，前序就是根左右

### B树
自平衡，快速查找插入和删除，适用于存储系统，如数据库和文件系统，这些系统需要处理大量的读写操作。一个m阶子树，必须遵守：

- 每个节点最多有m个子节点，最多有k-1个键(一个包含k个键的非叶子节点，**必须**有k+1个子节点)
- 所有叶子节点都在同一层
- 除了根节点，每个内部节点至少有 ⌈m/2⌉ 个子节点（向上取整），包括子节点至少有⌈m/2⌉-1个键。

插入操作总是从叶子节点开始。首先，查找到适合插入新键的叶子节点。

* **节点未满：** 如果该叶子节点有足够的空间，直接将新键插入到正确的位置，保持节点内键的有序性。
* **节点已满：** 如果该叶子节点已满（已达到 `m-1` 个键），插入新键会导致节点溢出。此时需要进行**节点分裂**：
    1.  将该节点的所有键（包括新插入的键）排序，找到中间位置的键。
    2.  将中间键提升到其父节点中。
    3.  以中间键为界，将原节点分裂成两个新的节点，分别包含小于和大于中间键的键。
    4.  如果父节点因为提升而溢出，则对父节点重复分裂过程，这个过程可能一直向上传播，最坏的情况下会导致根节点分裂，从而使树的高度增加一层。

删除需要考虑两种情况

* **情况一：键在叶子节点**
    * 如果删除后，该节点的键数量仍然满足最小数量要求（大于等于 `⌈m/2⌉ - 1`），则直接删除。
    * 如果删除后，键数量不满足要求（发生下溢），则需要进行调整：
        1.  **从兄弟节点借键：** 如果其相邻的兄弟节点比较“富裕”（键数量大于最小要求），则可以从兄弟节点借一个键过来，并通过父节点进行调整，以重新达到平衡。
        2.  **与兄弟节点合并：** 如果相邻的兄弟节点也都“刚刚好”（只有最小数量的键），则需要将该节点与一个兄弟节点以及父节点中分隔它们的键进行合并。这个合并过程可能会导致父节点下溢，需要递归地向上进行调整。

* **情况二：键在内部节点**
    * 找到该键的前驱或后继键（左边的最大或右边的最小叶子节点，因为这两个作为根可以保证还符合左边都小于右边都大于），用前驱或后继键替换要删除的键，然后问题就转化为删除叶子节点中的前驱或后继键。

#### 例子

设一个m=3的B树，初始根为
```
   [10, 20]
```
向其中插入5，发生分裂
```
      [10]
     /    \
   [5]    [20]
```
再插入30
```
      [10]
     /    \
   [5]    [20, 30]
```
再插入40，这里不把30作为10的右节点，20和40作为30的子节点是因为这样会导致右边有3层，左边有2层，不符合平衡原则：
```
      [10, 30]
     /    |    \
   [5]   [20]  [40]
```
再插入50，60发生父节点溢出
```
         [30]         
        /    \
     [10]      [50]       
    /   \      /   \
  [5]   [20]  [40]  [60]   
```
删除5，此时子节点不满足最低要求且无法向20借，所以10下溢与20合并
```
          [30]
         /    \
       []      [50] 
      /        /   \
  [10, 20]    [40]  [60]
```
递归检查原父节点不满足最小节点要求，30下溢与50合并
```
      [30, 50]  
     /    |    \
 [10, 20] [40] [60]
```
如果要删除的是30，则交换30与20(左边最大，也可以与40)，最后变为
```
      [20, 50] 
     /    |    \
 [5, 10] [40]  [60]
```

**22.08** 找删除260后不可能的根节点
![](https://res.cloudinary.com/dkdhhe5fc/image/upload/v1751777984/Snipaste_2025-07-06_12-59-31_drp0da.png)

A. 60, 90, 280
B. 60, 90, 350
C. 69, 85, 110, 350
D. 60, 90, 110, 350

##### 1. 分析B树的基本属性

* **阶数 (Order) m = 5**。
* **每个节点最多键数**: m - 1 = 4。 (当前根节点已满)
* **每个节点最少键数 (除根节点外)**: ⌈m/2⌉ - 1 = ⌈2.5⌉ - 1 = 3 - 1 = 2。

##### 2. 分析删除操作

我们要删除的键是 `260`，它位于**内部节点**（根节点）。

根据B树的规则，删除内部节点的键不能直接拿掉，必须执行以下步骤：
1.  找到该键的**中序前驱**或**中序后继**。
2.  用前驱或后继的值**替换**要删除的键 `260`。
3.  将问题转化为**删除那个叶子节点中的前驱或后继**。

这给了我们两种可能的操作路径。

---

##### 路径一：使用“中序后继”替换 `260`

1.  **找到后继**: `260` 的中序后继是其右子树中最小的键，即 `[280, 300]` 中的 **`280`**。
2.  **替换**: 用 `280` 替换根节点的 `260`。根节点暂时变为 `[60, 90, 280, 350]`。
3.  **转化问题**: 现在的问题是从叶子节点 `[280, 300]` 中删除 `280`。
4.  **删除叶子键**: 删除后，该叶子节点变为 `[300]`。
5.  **检查下溢**: 节点 `[300]` 只有1个键，小于最少键数 `2`，发生**下溢 (Underflow)**。
6.  **修复下溢**:
    * **尝试借用**: 它的左兄弟是 `[100, 110]`（有2个键），右兄弟是 `[400, 500]`（有2个键）。它们都处于最少键数的临界状态，没有“余粮”可借。
    * **必须合并**: 因为无法借用，只能与兄弟合并。这里又有两种选择：

    * **选择A: 与左兄弟合并**
        * 合并对象：下溢节点 `[300]`、左兄弟 `[100, 110]`、以及它们在父节点（根）中的分隔键 `280`。
        * 合并结果：形成一个新节点 `[100, 110, 280, 300]`。
        * 根节点变化：因为分隔键 `280` 被拉下去参与合并，根节点变为 **`[60, 90, 350]`**。
        * **结论：选项 B 是可能的。**

    * **选择B: 与右兄弟合并**
        * 合并对象：下溢节点 `[300]`、右兄弟 `[400, 500]`、以及它们在父节点（根）中的分隔键 `350`。
        * 合并结果：形成一个新节点 `[300, 350, 400, 500]`。
        * 根节点变化：因为分隔键 `350` 被拉下去参与合并，根节点变为 **`[60, 90, 280]`**。
        * **结论：选项 A 是可能的。**

---

##### 路径二：使用“中序前驱”替换 `260`

1.  **找到前驱**: `260` 的中序前驱是其左子树中最大的键，即 `[100, 110]` 中的 **`110`**。
2.  **替换**: 用 `110` 替换根节点的 `260`。根节点暂时变为 `[60, 90, 110, 350]`。
3.  **转化问题**: 现在的问题是从叶子节点 `[100, 110]` 中删除 `110`。
4.  **删除叶子键**: 删除后，该叶子节点变为 `[100]`。
5.  **检查下溢**: 节点 `[100]` 只有1个键，发生下溢。
6.  **修复下溢**:
    * **尝试借用**:
        * 它的右兄弟 `[280, 300]` 只有2个键，无法出借。
        * 它的左兄弟 `[70, 80, 85]` 有3个键，比最少键数多1个，**可以出借**！
    * **执行借用 (旋转)**:
        * 父节点（根）的分隔键 `90` 下沉到下溢节点 `[100]` 中，使其变为 `[90, 100]`。
        * 左兄弟 `[70, 80, 85]` 中最大的键 `85` 上升到父节点（根）中，取代 `90` 的位置。
        * 根节点变化：根节点最终变为 **`[60, 85, 110, 350]`**。
    * **结论：一个形如 `[60, 85, 110, 350]` 的根节点是可能的。**

---
综上D不可能

### 哈夫曼编码
哈夫曼树用子节点表示字符，左0右1。定长编码子节点必须在同一层
![](https://res.cloudinary.com/dkdhhe5fc/image/upload/v1751771455/Snipaste_2025-07-06_11-07-19_qtaqkc.png)
构建哈夫曼树的过程是合并最小的两个直到只剩一个值，如[23.04]构建3,4,5,6,8,10，合并过程为
3 4 -> 5 6 7 8 10
5 6 -> 7 8 10 11
7 8 -> 10 11 15
10 11 -> 15 21
15 21 -> 36
然后根据这个过程倒着构建树，最后一步36是根15 21是左右子树，然后上一步21是根10 11是左右子树，结果如下
![](https://pub-35b33650d5944267a2f7969ac8f72430.r2.dev/Snipaste_2025-07-31_18-35-11.png)