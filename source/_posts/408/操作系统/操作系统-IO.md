---
title: 操作系统-IO
date: 2025-07-06 14:51:14
categories:
    - 408
    - 操作系统
---

总线是连接计算机各个部件（CPU、内存、I/O控制器）的一组共享的电子线路，是它们之间通信的公共通道。

* **数据总线 (Data Bus)**：双向传输数据。总线的宽度（如32位、64位）决定了单次能传输的数据量，是影响性能的关键。
* **地址总线 (Address Bus)**：单向传输，由CPU发出，用于指明要访问的内存单元或I/O端口的地址。总线宽度决定了最大寻址空间（如32位地址线对应$2^{32}$B=4GB的寻址空间）。
* **控制总线 (Control Bus)**：传输控制信号和时序信号，如读/写信号、中断请求、总线请求等，协调各部件的操作。

## I/O控制方式
目标是把CPU从繁琐、低效的I/O任务中解脱出来，去执行更有价值的计算任务

### 1. 程序直接控制方式 (Programmed I/O)

也称为 **轮询方式 (Polling)** 或 **忙等方式 (Busy-Waiting)**。这是最原始、最简单的控制方式。

* **核心思想**：CPU亲自“下场”全程监工。轮询I/O设备的状态，直到设备就绪为止。

* **特点与评价**：
    * **优点**：实现逻辑非常简单。
    * **致命缺点**：CPU在等待期间处于“**忙等**”状态，无法执行其他任何程序，导致**CPU利用率极低**。对于稍慢的设备，这会造成CPU资源的巨大浪费。

### 2. 中断驱动方式 (Interrupt-driven I/O)

这是对程序I/O方式的重大改进，引入了“报告”机制。

* **核心思想**：CPU布置完任务就去忙别的，设备完成后主动向CPU“打报告”。
* **工作流程**：
    1.  **CPU发出指令**：CPU向设备控制器发出一个I/O指令。
    2.  **CPU转去执行其他程序**：CPU不再等待，而是将控制权交给其他进程，去执行其他计算任务。
    3.  **设备自行准备**：I/O设备和其控制器独立工作，准备数据。
    4.  **设备发送中断**：当I/O操作完成时（例如，键盘敲击了一个字符，数据已在控制器缓冲区），设备控制器会通过控制总线向CPU发送一个**中断请求信号**。
    5.  **CPU响应中断**：CPU在执行完当前指令后，会检测到中断信号。它会立即**保护被中断程序的现场**（保存寄存器等），然后转去执行对应的**中断服务程序 (Interrupt Service Routine, ISR)**。
    6.  **中断程序处理数据**：在中断服务程序中，**CPU**负责将数据从设备控制器传输到内存。
    7.  **CPU恢复现场**：中断服务程序执行完毕后，CPU**恢复之前保存的现场**，使被中断的程序能继续无缝执行。

* **特点与评价**：
    * **优点**：通过中断机制，CPU无需忙等，**极大地提高了CPU的利用率**，实现了CPU与I/O设备的并行工作。
    * **缺点**：数据的传输本身（一个字一个字地搬运）**仍然需要CPU来完成**（在中断服务程序中）。如果I/O设备速度很高，数据量很大，频繁的中断和数据搬运会耗费CPU大量时间。

### 3. DMA (直接存储器存取) 方式

这是对中断方式的进一步优化，引入了专业的“搬运工”。

* **核心思想**：CPU只负责“下达指令”和“最终验收”，中间的数据搬运过程全权委托给专业的**DMA控制器 (DMAC)**。
* **工作流程**：
    1.  **CPU进行设置**：当进程需要进行I/O时，CPU向**DMAC**下达指令，设置好几个关键参数：
        * 要进行的操作（读/写）。
        * 数据在内存中的起始地址。
        * 要传输的数据块大小（字节数）。
        * 要操作的I/O设备地址。
    2.  **CPU转去执行其他程序**：设置完成后，CPU就可以完全脱身，去执行其他进程，就像什么都没发生一样。
    3.  **DMAC全权负责传输**：DMAC接管总线控制权，在I/O设备和主存之间**直接**进行一整块数据的传输，**无需CPU介入**。
    4.  **DMAC发送中断**：当**一整块数据**传输完毕后，DMAC向CPU发送一个**中断请求**。
    5.  **CPU响应中断**：CPU响应这个中断，得知整个传输任务已完成，然后进行后续处理。

* **特点与评价**：
    * **优点**：数据传输过程完全由DMAC完成，CPU只在开始和结束时介入，**几乎完全解放了CPU**，CPU利用率达到最高。是高速设备进行块数据传输的**不二之选**。
    * **缺点**：需要更复杂的硬件（DMAC）支持。

### 核心对比总结

| 对比维度 | 程序直接控制 (轮询) | 中断驱动 | DMA方式 |
| :--- | :--- | :--- | :--- |
| **数据传输单位** | 一个字/字节 | 一个字/字节 | **一整块** |
| **CPU干预程度** | **全程参与**，监视和传输 | **部分参与**，仅处理数据传输 | **开始和结束时参与**，不参与传输 |
| **CPU工作状态** | **忙等**，无法并行 | **可并行**，CPU可执行其他任务 | **可并行**，CPU可执行其他任务 |
| **中断作用** | 无中断 | I/O完成后**请求CPU处理数据** | I/O完成后**通知CPU任务已完成** |
| **主要优点** | 实现简单 | CPU利用率高 | CPU利用率极高，传输速度快 |
| **主要缺点** | CPU利用率极低 | 频繁中断仍耗费CPU时间 | 硬件设计复杂，成本高 |
| **适用设备** | 早期或极简单的设备 | 键盘、鼠标等低速设备 | **磁盘、网卡**等高速设备 |

**22.21** 下列关于中断 I/O 方式的叙述中，不正确的是（ ）。

A. 适用于键盘、针式打印机等字符型设备
B. 外设和主机之间的数据传送通过软件完成
C. 外设准备数据的时间应小于中断处理时间
D. 外设为某进程准备数据时 CPU 可运行其他进程

中断服务程序是软件，B正确

* **外设准备数据的时间**：指从启动外设到外设完成工作（例如，用户按下下一个键、磁盘磁头找到磁道）并发出中断信号所花费的时间。对于慢速设备，这个时间通常很**长**（毫秒级甚至秒级）。
* **中断处理时间**：指CPU响应中断、保存现场、执行中断服务程序（传送一个或几个字节）、恢复现场所花费的时间。这个时间非常**短**（微秒级或纳秒级）。
中断I/O的全部意义就在于，利用那段**漫长的“外设准备数据的时间”**去执行其他任务。如果外设准备数据的时间比中断处理本身的时间还要短，则没有意义，且可能导致覆盖缓冲区数据，C错

[22.32] 下列关于驱动程序的叙述中，不正确的是( )。
A. 驱动程序与 I/O 控制方式无关
B. 初始化设备是由驱动程序控制完成的
C. 进程在执行驱动程序时可能进入阻塞态
D. 读/写设备的操作是由驱动程序控制完成的

显然A错

## 设备无关性软件/设置独立性软件

### I/O操作分层调用

#### 1\. 用户层I/O软件 (User-Level I/O Software)

这是最靠近用户和应用程序的一层，它为程序员提供了最方便的调用接口。

  * **功能**：
      * 提供简单易用的库函数接口，如C语言标准库中的 `printf()`、`scanf()`、`fopen()`、`fread()` 等。
      * 进行数据的格式化（例如，`printf` 会将二进制整数转换为十进制字符串）。
  * **工作机制**：这一层的代码是用户程序的一部分，运行在**用户态**。当这些库函数被调用时，它们会通过**系统调用 (System Call)** 的方式，请求内核中的I/O服务。例如，`fread` 函数最终会调用内核提供的 `read` 系统调用。
  * **核心作用**：为程序员提供便利，隐藏系统调用的细节。

#### 2\. 设备无关性软件 (Device-Independent OS Software)

这是I/O软件的核心，也是实现“设备无关性”的关键所在。它位于操作系统内核中，承上启下。

  * **功能**：它的目标是为所有（或一类）I/O设备提供统一的框架和通用的功能。
      * **统一接口**：向上层的用户进程提供统一的、标准化的接口，如 `read`, `write`, `open`, `close`。著名的 “Linux/Unix中一切皆文件” 的哲学思想就体现在这一层。无论是读磁盘文件、读键盘、还是读网络套接字，都可以使用相同的 `read` 系统调用。
      * **设备命名**：负责设备名到设备驱动程序的映射。例如，将路径名 `/dev/disk0` 映射到对应的磁盘驱动程序。
      * **设备保护**：检查用户进程是否有权限访问指定的设备。
      * **提供缓冲**：管理I/O缓冲（我们下一部分会详细讲），以提高性能。
      * **错误处理**：处理来自下层设备驱动程序的错误，并以统一的方式报告给上层。
      * **设备分配与回收**：对独占型设备（如打印机）进行分配和回收管理。
  * **核心作用**：屏蔽设备差异，提供统一视图。应用程序员在调用`write`时，无需关心写入的是SSD、HDD还是U盘。

#### 3\. 设备驱动程序 (Device Drivers)

这是操作系统中与具体硬件直接打交道的部分。

  * **功能**：它是特定硬件设备的“专属翻译官”。
      * 接收来自上层（设备无关性软件层）的抽象请求（例如，“读取磁盘的第500号逻辑块”）。
      * 将这些抽象请求**翻译**成特定设备控制器能听懂的具体指令（例如，向设备控制器的命令寄存器写入某个值，向地址寄存器写入柱面号、磁头号、扇区号等）。
      * 启动设备工作，并处理设备完成后的中断。
  * **核心作用**：**设备相关性**都封装在这一层。这也是为什么当你为电脑添加一个新显卡或打印机时，需要“安装驱动程序”的原因——你正在为操作系统提供这个特定硬件的“翻译官”。

#### 4\. 中断处理程序 (Interrupt Handlers)

这是I/O软件的最底层，直接响应硬件中断。

  * **功能**：
      * 当I/O操作完成，设备控制器发出中断信号时，CPU会暂停当前工作，转而执行中断处理程序。
      * 程序首先要**保护被中断进程的现场**。
      * 分析中断原因，并进行相应的处理。例如，从设备控制器中读取状态信息，或者唤醒正在等待此次I/O完成的设备驱动程序（进程）。
      * 执行必须**尽可能快**，因为它在中断上下文中运行，会阻塞其他中断。
  * **核心作用**：作为硬件和I/O软件其余部分的桥梁，处理硬件发来的“通知”，并启动软件层面的后续响应。

以一个 `read` 请求为例，梳理整个流程：

1.  **用户进程**调用 `read()` 库函数。
2.  **用户层软件**通过**系统调用**陷入内核。
3.  **设备无关性软件**检查参数合法性、权限，然后向对应的**设备驱动程序**发出一个通用的读请求。
4.  **设备驱动程序**将请求翻译成设备控制器能懂的命令，写入控制器的寄存器，启动I/O。
5.  CPU转去执行其他进程，驱动程序自身则可能进入**阻塞**等待状态。
6.  设备完成数据准备，向CPU发送**中断**。
7.  **中断处理程序**被执行，分析中断，唤醒等待的设备驱动程序。
8.  **设备驱动程序**被唤醒后，可能会进行数据处理、状态检查，并通知上层的**设备无关性软件**。
9.  **设备无关性软件**将结果和数据返回给用户进程，用户进程从系统调用中返回，`read()` 函数执行完毕。

### 缓冲
CPU和内存的速度远快于I/O设备，所以需要缓冲区
- 单缓冲，不能同时读/写
- 双缓冲，一个缓冲读时可以在另一个写
- 循环缓存，组成环，设置两个指针，一个指向下一个可用的空缓冲区（供I/O设备使用），另一个指向下一个已填满数据的缓冲区（供CPU使用）。两个指针以环形方式追赶。
- 缓冲池，由系统统一管理的一个由多个缓冲区组成的池。根据状态，缓冲区可以被组织成多个队列，如空闲队列、输入队列、输出队列。当需要输入时，从空闲队列取出一个缓冲区，装满数据后挂入输入队列。当需要输出时，将用户数据装入从空闲队列取出的缓冲区，然后挂入输出队列。这是一种更通用、更灵活的缓冲管理策略，被现代操作系统广泛采用。

### SPOOLing
**SPOOLing** 是 “**S**imultaneous **P**eripheral **O**perations **O**n-**L**ine” 的缩写，意为“**联机情况下的外围设备同步操作**”。

* **要解决的问题**：如何让一个独占的、慢速的设备（最典型的就是**打印机**）能够被多个用户进程“同时”使用，并且不让用户进程因为等待打印机而阻塞。
* **核心思想**：**用高速共享设备（磁盘）来模拟低速独占设备**。它在磁盘上开辟出专门的空间作为“输入井”和“输出井”，作为超大的缓冲区。
* **工作流程（以打印为例）**：
    1.  当用户进程请求打印输出时，操作系统并不直接将数据送给打印机，而是通过一个叫做**“输出进程”（或“打印守护进程”）**的服务，将打印数据高速地写入到磁盘的“**输出井**”中。对于用户进程来说，这个过程极快，它会感觉打印瞬间就完成了，然后可以继续做其他事。
    2.  真正的物理打印机由另一个**“SPOOLing输出进程”**专门管理。这个进程会不断地检查“输出井”，如果井中有待打印的文件，并且打印机当前空闲，它就从井中取出文件，一点一点地送给打印机进行物理打印。
* **SPOOLing系统的组成**：
    * **输入/输出井**：磁盘上的缓冲区。
    * **输入/输出进程**：负责在内存和井之间交换数据。
    * **输入/输出缓冲区**：内存中的小缓冲区，用于配合井的工作。
* **优点**：
    * **虚拟化设备**：将一个独占设备改造成了可供多用户共享的虚拟设备。
    * **提高I/O并行度**：实现了用户进程与慢速I/O设备操作的并行，用户进程不会被阻塞。
    * **提高设备利用率**：只要输出井里有任务，打印机就可以不停地工作。

注意缓冲通常在内存中，而SPOOLing在磁盘上建立缓冲区

[23.46] (8 分) 进程 P 通过执行系统调用从键盘接收一个字符的输入。已知此过程中与进程 P 相关的操 作包括：① 将进程 P 插入就绪队列；② 将进程 P 插入阻塞队列；③ 将字符从键盘控制器读入系 统缓冲区；④ 启动键盘中断处理程序；⑤ 进程 P 从系统调用返回；⑥ 用户在键盘上输入字符。 以上编号 ①~⑥ 仅用于标记操作，与操作的先后顺序无关。请回答下列问题。

(1) 按照正确的操作顺序，操作 ① 的前一个和后一个操作分别是上述操作中的哪一个？操作 ⑥ 的后一个操作是上述操作中的哪一个？
(2) 在上述哪个操作之后，CPU 一定是从进程 P 切换到其他进程？在上述哪个操作之后 CPU 调 度程序才能选中进程 P 执行？
(3) 完成上述哪个操作的代码属于键盘驱动程序？
(4) 键盘中断处理程序执行时，进程 P 处于什么状态？CPU 处于内核态还是用户态？

整个过程的流程如下：
1.  **进程 P 执行系统调用** (例如 `read()` 函数)，请求从键盘读一个字符。这导致程序从用户态陷入内核态。
2.  操作系统内核接管，发现需要等待外部设备（键盘）输入，而此时数据还未准备好。
3.  **② 将进程 P 插入阻塞队列**。操作系统将进程 P 的状态从“运行”改为“阻塞”，并将其放入等待键盘输入的阻塞队列中。
4.  **CPU调度**。由于进程 P 已阻塞，操作系统会调用调度程序，从就绪队列中选择另一个进程来运行。**（此时 CPU 从进程 P 切换出去）**
5.  ...一段时间后，用户在键盘上进行操作...
6.  **⑥ 用户在键盘上输入字符**。这是一个物理事件。
7.  键盘硬件控制器检测到按键，向 CPU 发送一个**中断信号**。
8.  **④ 启动键盘中断处理程序**。CPU 暂停当前正在执行的任何进程，保存其上下文，然后跳转到操作系统内核中预设的键盘中断处理程序代码。
9.  **③ 将字符从键盘控制器读入系统缓冲区**。中断处理程序（驱动程序的一部分）从键盘的硬件端口读取字符数据，并存放到内核的内存缓冲区中。
10. 中断处理程序发现有进程（即P）正在等待这个数据，于是需要唤醒它。
11. **① 将进程 P 插入就绪队列**。操作系统将进程 P 的状态从“阻塞”改为“就绪”，并将其从阻塞队列移到就绪队列。此时 P 已准备好运行，但尚未获得 CPU。
12. 中断处理程序执行完毕，CPU 恢复之前被中断的进程。
13. ...又过了一段时间，当 CPU 调度再次发生时（例如当前进程时间片用完）...
14. **CPU调度程序选中进程 P 执行**。
15. 进程 P 恢复运行（仍在内核态），操作系统将内核缓冲区中的字符复制到进程 P 的用户空间。
16. **⑤ 进程 P 从系统调用返回**。系统调用执行完毕，CPU 从内核态切换回用户态，进程 P 继续执行 `read()` 之后的代码。
所以整个顺序就是②⑥④③①⑤

(2) ② ①
(3) ③
(4) 阻塞态，内核态