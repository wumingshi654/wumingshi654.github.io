---
title: 操作系统-进程与线程
date: 2025-07-06 16:21:11
categories:
    - 408
    - 操作系统
---
## 进程概念
![](https://res.cloudinary.com/dkdhhe5fc/image/upload/v1751790028/Snipaste_2025-07-06_16-20-12_dd28ws.png)

- 就绪->运行：调度，获得CPU资源
- 运行->就绪:时间片用完，让出CPU；可剥夺操作系统还可以直接抢
- 运行->阻塞：通常是主动的，如进程读文件，申请外设，执行信号量wait等操作
- 阻塞->就绪：进程等待的事件到来时，如I/O操作完成或中断结束，中断处理程序必须将相应进程的状态由阻塞态转为就绪态

[23.27] 下列由当前线程引起的事件或执行的操作中，可能导致该线程由执行态变为就绪态的是( )。
A. 键盘输入
B. 缺页异常
C. 主动出让 CPU
D. 执行信号量的 wait() 操作

`wait()` 操作（也称P操作）用于请求一个资源。
* **情况1**：如果信号量的值大于0，表示有可用资源。线程会成功获取资源并继续处于**执行态**，状态不发生改变。
* **情况2**：如果信号量的值等于0，表示无可用资源。线程必须等待其他线程释放该资源（执行 `signal()` 操作）。在这种情况下，线程会因为等待资源而被放入该信号量的等待队列中，进入**阻塞态**。

只有C可能

## CPU调度
1.  **高级调度 (作业调度)**: 发生频率最低。它决定将哪些在外存（硬盘）上的作业调入内存，并为它们创建进程。它控制着系统的**并发度**（同时存在于内存中的进程数量）。
2.  **中级调度 (内存调度)**: 介于高低之间。为了缓解内存压力，它决定将内存中哪些暂时不能运行的进程（通常是阻塞态或就绪态）换出到外存，以及何时将它们换回内存。这个过程也叫**交换 (Swapping)**。
3.  **低级调度 (CPU调度)**: 发生频率最高。它直接从内存的**就绪队列**中，按照特定算法选取一个进程，并为其分配CPU。**我们通常所说的进程调度，主要指的就是低级调度。**

调度方法有：

- 先来先服务
- 短作业优先
- 高响应比优先

$$
    \text{响应比} = \frac{\text{等待时间} + \text{服务时间}}{\text{服务时间}}
$$

- 时间片轮转
- 优先级调度
- 多级反馈队列,最复杂也最接近现代操作系统的算法。它设置多个就绪队列，每个队列有不同优先级，且通常优先级越高的队列时间片越小。
    1.  新进程先进入最高优先级队列（如Q1），按FCFS等待。
    2.  轮到它时，在Q1的小时间片内运行。如果完成，则离开；如果没完成，则移入次级队列（Q2）的队尾。
    3.  只有当Q1为空时，才会调度Q2的进程。Q2的时间片通常比Q1长。
    4.  以此类推。最低优先级队列通常采用FCFS。
    5.  为了防止饥饿，可以加入“老化”机制，如在某队列等待太久的进程可以被移回更高优先级队列。

## 同步与互斥
一次只允许一个进程使用的就是临界资源。对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。 为了保证临界资源的正确使用，可将临界资源的访问过程分成 4 个部分：

### 同步与互斥的基本概念

1)  **进入区**。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临 界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。
2)  **临界区**。进程中访问临界资源的那段代码，又称临界段。
3)  **退出区**。将正在访问临界区的标志清除。
4)  **剩余区**。代码中的其余部分。


```
while (true) {
  entry section;        // 进入区
  critical section;     // 临界区
  exit section;         // 退出区
  remainder section;    // 剩余区
}
```

- 同步是直接制约关系，就是一些进程的执行的合作关系
- 互斥是间接制约关系，对临界资源的互斥

为禁止两个进程同时进入临界区，同步机制应遵循以下准则：
- 空闲让进
- 忙则等待
- 有限等待
- 让权等待，非必须，要求进程不能进入临界区时应立即释放处理器，防止进程忙等待

### 实现临界区互斥的基本方法
#### 软件实现方法

- 单标志法，假设有两个进程，设置一个标志turn，turn=0时允许P0进入，P0完成后将turn设为1，turn=1允许P1进入，P1完成后将turn设为0. 最大问题在于**必须**交替进入，如P0进入一次后此时turn=1，则必须等P1进入一次turn才能变为0，P0才能再次进入，违反空闲让进
- 双标志法，该算法设置一个布尔型数组 flag[2]，用来标记各个进程想进入临界区的意思，flag[i]=true 表 示 $P_i$ 想要进入临界区 ($i=0$ 或 $1$)。$P_i$ 进入临界区前，先检查对方是否想进入临界区，若想，则等 待；否则，将 flag[i]置为 true 后，再进入临界区；当 $P_i$ 退出临界区时，将 flag[i]置为 false。缺点是按下面1234的步骤会导致P0 P1同时进入临界区，原因在于检查和设置操作不是原子的。
```
// 进程 P0:
while (flag[1]);         // 1
flag[0] = true;          // 3
critical section;
flag[0] = false;
remainder section;

// 进程 P1:
while (flag[0]);         // 2
flag[1] = true;          // 4
critical section;          // 临界区
flag[1] = false;           // 退出区
remainder section;       // 剩余区
```
- 双标志后检查法，把双标志法的检查放在设置后，如下按1234执行，会导致两个进程都认为对方想进入临界区，结果卡在34步谁也进不了，违反有限等待
```
// 进程 P0:
flag[0] = true;         // 1
while (flag[1]);          // 3
critical section;
flag[0] = false;
remainder section;

// 进程 P1:
flag[1] = true;         // 2
while (flag[0]);          // 4
critical section;          // 临界区
flag[1] = false;           // 退出区
remainder section;       // 剩余区
```
- Peterson算法，结合了单标志和双标志后检查，除了不能“让权等待”其他都没问题
```
// 进程 P0:
flag[0] = true; 
turn=1;
while (flag[1] && turn==1); 
critical section;
flag[0] = false;
remainder section;
// P1同理
```
#### 硬件实现方法
由上可知软件实现都有或多或少的问题，Peterson算法理论上可行，但在现代多核CPU上几乎必然失效。硬件实现可以很好的解决临界区互斥问题
- 中断屏蔽方法，CPU**只能**在发生中断时引起进程切换，所以进入临界区前关中断，执行完后开中断即可。这样的缺点很明显：限制CPU效率；不应该交由用户操作关中断；对多核系统无效
- TestAndSet指令，在一个原子操作中检查变量并设置值，如下面如果lock为false，则将lock设为true并进入临界区；反之循环等待。这种方法lock是共享的可用于多核系统，但不能“让权等待”
```
while TestAndSet(&lock);    //加锁并检查
进程的临界区代码段
lock=false; //解锁
```
- Swap方法，在一个原子操作中交换两个值。首先定义一个全局共享的布尔型变量 `lock`，`FALSE` 表示锁空闲，`TRUE` 表示锁被占用。每个希望进入临界区的进程都需要一个自己的局部布尔型变量 `key`。
* 进程先将自己的局部变量 `key` 设置为 `TRUE`。这代表了该进程“想要上锁”的意图。
    * 进程在一个循环中，原子性地调用 `Swap(key, lock)` 指令。
    * **检查结果**: `Swap` 指令执行后，`lock` 的旧值会被存入 `key`，而 `key` 的旧值 (`TRUE`) 会被存入 `lock`。此时检查 `key` 的新值：
        * 如果 `key` 的新值为 `FALSE`：这说明在交换之前，`lock` 是 `FALSE`（锁是空闲的）。那么该进程已成功获得锁（因为 `lock` 现在是 `TRUE` 了），可以退出循环，进入临界区。
        * 如果 `key` 的新值为 `TRUE`：这说明在交换之前，`lock` 就是 `TRUE`（锁已被占用）。本次交换并未改变 `lock` 的状态，获取锁失败。进程必须继续循环，再次尝试 `Swap`。
```
boolean key=true;
while(key!=false)
    Swap(&lock, &key);
lock=false;
```

### 互斥锁
分为获得锁acquire，释放锁release和锁是否可用available
```
acquire() {                     // 获得锁的定义
  while (!available)
    ;                           // 忙等待
  available = false;            // 获得锁
}
release() {                     // 释放锁的定义
  available = true;             // 释放锁
}
```

### 信号量
wait-P(roberen，尝试)  signal-V(erhogen，增加) 因为是荷兰人Dijkstra 发明的，后面是荷兰语，Dijkstra 算法也是这人
#### 记录型信号量
不存在“忙等”的机制，定义数据结构记录资源数value和等待该资源的进程链表L，PV操作要紧跟使用临界资源的操作
```
typedef struct{
    int value;
    struct process *L;
}semaphore;

void wait(semaphore S){ //相当于申请资源
    S.value--;
    if(S.value<0){
        add this process to S.L;
        block(S.L); // 将进程设为阻塞态，主动放弃CPU
    }
}

void signal(semaphore S){
    S.value++;
    if(S.value<=0){
        remove a process P from S.L;
        wakeup(P);  //唤醒线程
    }
}
```
#### 使用信号量实现前驱关系
![](https://pub-35b33650d5944267a2f7969ac8f72430.r2.dev/Snipaste_2025-08-03_17-32-05.png)
如上图，S1-S2表示为a12，其他同理，则使用信号量表示如下：
```
semaphore a12=a13=a24=a25=a36=a46=a56=0; // 初始化信号量

S1() {
  ...;
  V(a12); V(a13);            // S1 已经运行完成
}

S2() {
  P(a12);                     // 检查 S1 是否运行完成
  ...;
  V(a24); V(a25);            // S2 已经运行完成
}

S3() {
  P(a13);                     // 检查 S1 是否已经运行完成
  ...;
  V(a36);                     // S3 已经运行完成
}

S4() {
  P(a24);                     // 检查 S2 是否已经运行完成
  ...;
  V(a46);                     // S4 已经运行完成
}

S5() {
  P(a25);                     // 检查 S2 是否已经运行完成
  ...;
  V(a56);
}

S6() {
  P(a36); 
  P(a46); 
  P(a56); 
  ...;
}
```

### 经典同步问题
#### 生产者-消费者问题
生产者消费者+大小为n的缓冲区
```
// 初始化信号量
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

Producer() {
    while (TRUE) {
        // 1. 在缓冲区之外生产一个物品
        produce an item in nextp;

        // 2. 等待一个空闲的槽位
        // 如果 empty 为 0 (缓冲区已满)，则生产者会在此阻塞
        P(empty);

        // 3. 获取缓冲区的互斥访问权
        P(mutex);

        // --- 临界区开始 ---
        // 4. 将生产的物品放入缓冲区
        add nextp to buffer;
        // --- 临界区结束 ---

        // 5. 释放缓冲区的互斥访问权
        V(mutex);

        // 6. 通知消费者，物品 (full) 的数量增加了一个
        V(full);
    }
}

Consumer() {
    while (TRUE) {
        // 1. 等待一个可消费的物品
        // 如果 full 为 0 (缓冲区为空)，则消费者会在此阻塞
        P(full);

        // 2. 获取缓冲区的互斥访问权
        P(mutex);

        // --- 临界区开始 ---
        // 3. 从缓冲区中取出一个物品
        remove an item from buffer;
        // --- 临界区结束 ---

        // 4. 释放缓冲区的互斥访问权
        V(mutex);

        // 5. 通知生产者，空闲槽位 (empty) 的数量增加了一个
        V(empty);

        // 6. 在缓冲区之外消费取出的物品
        consume the item
    }
}
```

#### 读者-写者问题
读者-写者共享一个文件，可以多个进程读，但不能同时读和写，即写者写文件时必须保证没有任何读者。
首先是读者优先的实现，即读者可以插入到等待的写者之前
```
// 信号量初始化
semaphore rw_mutex = 1; // 用于写者和第一个读者
semaphore mutex = 1;    // 用于保护 read_count

// 共享计数器初始化
int read_count = 0;

Writer {
    while (TRUE) {
        // 1. 等待获取“读写锁”
        P(rw_mutex);
        // --- 临界区开始 ---
        // 2. 执行写操作
        writing is performed
        // --- 临界区结束 ---
        // 3. 释放“读写锁”
        V(rw_mutex);
    }
}

Reader() {
    while (TRUE) {
        // --- 进入区 ---
        // 1. 获取对 read_count 的互斥访问权
        P(mutex);
        // 2. 读者数量加 1
        read_count++;
        // 3. 判断自己是否是第一个读者. 23可以调换顺序
        if (read_count == 1) {
            // 如果是第一个读者，则需要负责去获取“读写锁”，这会阻止任何写者进入。
            P(rw_mutex);
        }
        // 4. 释放对 read_count 的互斥访问权
        // 后续的读者可以直接进入，因为 rw_mutex 已被第一个读者持有
        V(mutex);


        // --- 临界区开始 ---
        // 5. 执行读操作 (此时可以有多个读者)
        reading
        // --- 临界区结束 ---


        // --- 退出区 ---
        // 6. 再次获取对 read_count 的互斥访问权
        P(mutex);

        // 7. 读者数量减 1
        read_count--;

        // 8. 判断自己是否是最后一个读者
        if (read_count == 0) {
            // 如果是最后一个读者，则需要负责释放“读写锁”，
            // 以便让等待的写者可以进入。
            V(rw_mutex);
        }

        // 9. 释放对 read_count 的互斥访问权
        V(mutex);
    }
}
```
写者优先要更复杂
```
// 信号量初始化
semaphore r_mutex = 1;      // 保护 read_count
semaphore w_mutex = 1;      // 保护 write_count
semaphore read_try = 1;     // 允许读者尝试进入的“门”
semaphore resource = 1;     // 保护共享数据

// 共享计数器初始化
int read_count = 0;
int write_count = 0;

Writer() {
    while (TRUE) {
        // --- 进入区 ---
        // 1. 获取对 write_count 的互斥访问权
        P(w_mutex);
        
        // 2. 写者数量加 1
        write_count++;
        
        // 3. 如果是第一个到达的写者
        if (write_count == 1) {
            // 关上“读者门”，阻止任何新读者尝试进入
            P(read_try);
        }
        
        // 4. 释放对 write_count 的互斥访问权
        V(w_mutex);

        // 5. 等待获取共享资源的访问权
        P(resource);

        // --- 临界区开始 ---
        // 6. 执行写操作
        // ... writing is performed ...
        // --- 临界区结束 ---

        // 7. 释放共享资源
        V(resource);

        // --- 退出区 ---
        // 8. 再次获取对 write_count 的互斥访问权
        P(w_mutex);
        
        // 9. 写者数量减 1
        write_count--;
        
        // 10. 如果是最后一个离开的写者
        if (write_count == 0) {
            // 打开“读者门”，允许读者们进入
            V(read_try);
        }
        
        // 11. 释放对 write_count 的互斥访问权
        V(w_mutex);
    }
}

Reader() {
    while (TRUE) {
        // --- 进入区 ---
        // 1. 尝试通过“读者门”
        // 如果有写者正在等待，将会在此处被阻塞
        P(read_try);

        // 2. 获取对 read_count 的互斥访问权
        P(r_mutex);
        
        // 3. 读者数量加 1
        read_count++;
        
        // 4. 如果是第一个读者，这里34也可以换位，但注意如果换位read_count还没有自增，所以判断条件要改为 == 0
        if (read_count == 1) {
            // 负责为所有读者抢占共享资源
            // 这会阻止写者（即使是已在等待的写者）进入
            P(resource);
        }
        
        // 5. 释放对 read_count 的互斥访问权
        V(r_mutex);
        
        // 6. ！！！关键：立刻释放“读者门”，允许其他读者进入
        // 这样，在没有写者等待时，多个读者可以快速连续进入
        V(read_try);


        // --- 临界区开始 ---
        // 7. 执行读操作
        // ... reading is performed ...
        // --- 临界区结束 ---


        // --- 退出区 ---
        // 8. 获取对 read_count 的互斥访问权
        P(r_mutex);
        
        // 9. 读者数量减 1
        read_count--;
        
        // 10. 如果是最后一个离开的读者
        if (read_count == 0) {
            // 负责释放共享资源，以便写者可以使用
            V(resource);
        }
        
        // 11. 释放对 read_count 的互斥访问权
        V(r_mutex);
    }
}
```
#### 哲学家用餐问题
确保左右筷子都可用时再拿起
```
semaphore chopstick[5] = {1, 1, 1, 1, 1};  // 初始化信号量
semaphore mutex = 1;                     // 设置取筷子的信号量

Pi() {                                    // i 号哲学家的进程
  do {
    P(mutex);                              // 在取筷子前获得互斥量
    P(chopstick[i]);                       // 取左边筷子
    P(chopstick[(i+1)%5]);                 // 取右边筷子
    V(mutex);                              // 释放取筷子的信号量
    eat;                                   // 进餐
    V(chopstick[i]);                       // 取左边筷子
    V(chopstick[(i+1)%5]);                 // 取右边筷子
    think;
  } while (true);
}
```



## 23.45
现要求学生使用 swap 指令和布尔型变量 lock 实现临界区互斥。lock 为线程间共享的变量。 lock 的值为 TRUE 时线程不能进入临界区，为 FALSE 时线程能够进入临界区。某同学编写的实 现临界区互斥的伪代码如 (a) 所示。

请回答下列问题。
(1) (a) 的伪代码中哪些语句存在错误？将其改为正确的语句 (不增加语句条数)。
(2) (b) 给出了交换两个变量值的函数 newSwap() 的代码，是否可以用函数调用语句 “newSwap(&key, &lock)” 代替指令 “swap key,lock” 以实现临界区互斥？为什么？

(a)伪代码如下
```
bool lock = FALSE;
...
// 进入区
bool key = TRUE;
if(key == TRUE)
    swap key,lock;  //交换key和lock的值

临界区

lock=TRUE;  //退出区
```

(b) newSwap代码如下
```
void newSwap(bool *a, bool *b){
    bool temp = *a;
    *a = *b;
    *b = temp;
}
```

1) `if(key == TRUE)` 改为while
lock = TRUE 改为 lock = FALSE
2) 不能，因为swap指令具有原子性，而newSwap函数执行时会被分为三条指令，在线程切换时会导致竟态条件
假设 `lock` 初始为 `FALSE`，两个线程 T1 和 T2 同时尝试进入临界区。

1.  **T1 调用 `newSwap(&key1, &lock)`** (`key1` 为 `TRUE`)。
2.  T1 执行 `bool temp = *a;`，`temp` 被赋值为 `TRUE`。
3.  T1 执行 `*a = *b;`，`*a` 即 `key1`，`*b` 即 `lock`。`key1` 被赋值为 `FALSE`。
4.  **此时发生线程切换！** 操作系统挂起 T1，开始执行 T2。T1 还没来得及把 `lock` 设置为 `TRUE`。
5.  **T2 调用 `newSwap(&key2, &lock)`** (`key2` 为 `TRUE`)。
6.  因为 T1 被中断，`lock` 的值仍然是 `FALSE`。
7.  T2 完整地执行了 `newSwap` 函数的所有步骤：
      * `temp` 设为 `TRUE` (`key2` 的值)。
      * `key2` 设为 `FALSE` (`lock` 的值)。
      * `lock` 设为 `TRUE` (`temp` 的值)。
8.  T2 的 `newSwap` 调用结束，它的局部变量 `key2` 变为 `FALSE`。因此，T2 退出了 `while` 循环，**成功进入临界区**。
9.  **线程切换回来！** 操作系统恢复 T1 的执行。
10. T1 从中断处继续执行，它需要执行 `newSwap` 的最后一步：`*b = temp;`。T1 的 `temp` 在步骤2中被赋值为 `TRUE`。所以 T1 将 `lock` 设置为 `TRUE`。
11. T1 的 `newSwap` 调用也结束了。回顾步骤3，T1 的 `key1` 已经被赋值为 `FALSE`。因此，T1 也退出了 `while` 循环，**也成功进入了临界区**。

**结论**：T1 和 T2 都进入了临界区，互斥被完全破坏。这是因为 `newSwap()` 函数的非原子性允许在关键操作之间发生线程切换。