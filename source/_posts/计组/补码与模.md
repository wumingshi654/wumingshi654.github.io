---
title: 补码与模
date: 2025-06-21 15:41:33
categories:
    - 408
    - 计算机组成原理
mathjax: true
---

补码系统的根基是**模运算 (Modular Arithmetic)**，就像时钟一样。

* 一个 n 位的二进制系统，能表示的数的个数是 $2^n$。这个 $2^n$ 就是它的**模 (Modulus)**。
* 对于一个8位系统，模是 $2^8 = 256$。你可以把它想象成一个有256个刻度的表盘，从0到255。当你从255再加1时，就会溢出并“回卷”到0。

在数学中，一个数 `A` 的**加法逆元 (Additive Inverse)**，也就是它的相反数 `-A`，被定义为：
> **`A + (-A) = 0`**

在补码这个模运算系统中，这个定义就变成了：
> **`(A + (-A)) mod 2^n = 0`**

这意味着 `A + (-A)` 的和必须是 $2^n$ 的整数倍。最简单的情况就是，我们让 `A + (-A) = 2^n`。
所以，我们可以得到在补码系统中“求负”的数学定义：

$$(-A) = 2^n - A$$

### "取反加一"只是一个聪明的算法

现在，最关键的一步来了：如何用计算机硬件高效地计算 **$2^n - A$** 呢？

我们耍一个数学小花招，把公式变形一下：

$$2^n - A = (2^n - 1) - A + 1$$

让我们看看 `(2^n - 1)` 是什么：
* 在 n 位二进制中，$2^n$ 是 `1` 后面跟着 n 个 `0`（例如，8位时是 `1 0000 0000`）。
* 那么，$2^n - 1$ 就是 **n 个全为 `1` 的数**（例如，8位时是 `1111 1111`）。

当用一个全`1`的数去减另一个二进制数 `A` 时，效果就等同于**对 `A` 的每一位按位取反**。
* 例如 (4位)：`1111 - 1010 = 0101`。`0101` 正是 `1010` 的按位取反。

所以，我们的公式可以这样翻译：
$$(-A) = 2^n - A = \underbrace{(2^n - 1) - A}_{\text{按位取反}} + 1$$

**这证明了，“按位取反，末位加一”这个操作，从计算机电路的角度看，是实现数学定义 $(-A) = 2^n - A$ 的一个高效算法！**
